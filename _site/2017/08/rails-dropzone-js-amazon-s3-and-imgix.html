<!DOCTYPE HTML>
<html lang="en">
  <head>
  <meta charset="UTF-8">
  <title>Rails, Dropzone.js, Amazon S3 and imgix - Ryan Bigg</title>
  <link rel="shortcut icon" href="https://ryanbigg.com/favicon.png" type="image/x-icon">
  <link href="http://feeds.feedburner.com/ryanbigg" rel="alternate" title="The Life of a Radar" type="application/atom+xml" />
  <link href="https://fonts.googleapis.com/css?family=Nunito+Sans:400,700|Ubuntu+Mono:400,700,700i&display=swap" rel="stylesheet">
  <link rel='stylesheet' href='https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css'>
  <link rel='stylesheet' href='/css/style.css' media='screen'>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

  <body>
    <header class="topbar">
  <h1><a href="/">Ryan Bigg</a></h1>

  <div class='items'>
    <a href="/">Who?</a> &middot;
    <a href="/books">Books</a> &middot;
    <a href="/blog">Blog</a> &middot;
    <a href="/setup">Setup</a> &middot;
    <a href="/history">History</a> &middot;
    <a href="/now">Now</a> &middot;
    <a href="/mentoring">Mentoring</a>
  </div>
</header>

    <div class="main">
      <div class='content'>
        <div class='content-inner'>
          <article>
            <div class='center'>
              <a href="/2017/08/rails-dropzone-js-amazon-s3-and-imgix"><h2>Rails, Dropzone.js, Amazon S3 and imgix</h2></a>
              <small>28 Aug 2017</small>
            </div>
            <p>In this tutorial I’ll cover how you can upload files directly to S3 by using a feature called <code class="language-plaintext highlighter-rouge">PresignedPost</code>. I’ll then show how you can use <a href="https://imgix.com">imgix</a> to resize these images dynamically after they’ve been uploaded.</p>

<p>The Rails app that I use for this tutorial is <a href="https://github.com/radar/dropzone-example">dropzone-example</a>, with the <a href="https://github.com/radar/dropzone-example/tree/finished">finished branch</a> being the final version of the code from this tutorial.</p>

<h3 id="background">Background</h3>

<p>I’ve got a small hobby Rails app that I use to share photos with my extended family. This app had humble beginnings: it was a very light Rails application with one model that used <a href="https://rubygems.org/gems/paperclip">Paperclip</a> to handle the attachments. Paperclip works very well, and I especially love that I don’t have to care about <em>how</em> my photos get resized; Paperclip just does it – as long as you have the right things installed.</p>

<p>I got the attachments through to Paperclip by using the wonderful <a href="http://www.dropzonejs.com/">Dropzone.js</a>. A simple file input would also work, but I wanted to be able to upload multiple files from all kinds of devices. Dropzone lets me do that.</p>

<p>But then I wanted to add video support to this application. It’s at this point that I should mention three things: 1) this application is hosted on Heroku 2) Heroku’s request timeout is set to a hard 30 seconds 3) Australian internet is prohibitively slow and iPhone videos are so big that any video longer than 25 seconds does not upload within that 30 second window.</p>

<p>So I had to come up with an inventive solution. Googling for other people’s attempts to solve or workaround this problem suggest that the best solution was to upload to s3 directly; but then I would lose the automatic resizing for images that comes with Paperclip. Fortunately, I knew about <a href="https:/imgix.com">imgix</a>.</p>

<p>A lot of the other writings on the internet don’t really cover it from start-to-finish, and so I pieced all this together from many, many blog posts and documentation pages.</p>

<p>Contrary to my tweet earlier:</p>

<blockquote class="twitter-tweet" data-lang="en-gb"><p lang="en" dir="ltr">Hooked up dropzone + s3 direct file uploads and now I&#39;m going to keep all that knowledge to myself mwhahahaha</p>&mdash; A Ryan (@ryanbigg) <a href="https://twitter.com/ryanbigg/status/901668466599510017">27 August 2017</a></blockquote>
<script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>I’m not going to keep all this knowledge to myself, but instead I’ll share with you how I did it here.</p>

<h3 id="dropzone-setup">Dropzone setup</h3>

<p>I’m going to assume that people reading this already have at least a Rails application setup and they want to add this functionality to it. I’ve got a <a href="https://github.com/radar/dropzone-example">small example app</a> with dropzone added, if you want to take a look.</p>

<p>I’m going to go old-school on this: no Webpacker, no React. If you want those things I am sure you can figure it out.</p>

<p>To start with, you can download the Dropzone files from the Download link in the <a href="https://gitlab.com/meno/dropzone/blob/master/README.md">project’s README</a>. This will download the latest release. Extract this zip, and then move <code class="language-plaintext highlighter-rouge">dropzone.css</code> into <code class="language-plaintext highlighter-rouge">vendor/assets/stylesheets/dropzone.css</code>, and <code class="language-plaintext highlighter-rouge">dropzone.js</code> into <code class="language-plaintext highlighter-rouge">vendor/assets/javascripts/dropzone.js</code>. These two files will need to be required in both <code class="language-plaintext highlighter-rouge">application.scss</code> and <code class="language-plaintext highlighter-rouge">application.js</code>:</p>

<p><strong>application.scss</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*= require dropzone
</code></pre></div></div>

<p><strong>application.js</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//= require dropzone
</code></pre></div></div>

<p>Then wherever you want the dropzone to appear, put this code:</p>

<p><strong>app/views/uploads/new.html.erb</strong></p>

<div class="language-erb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;%=</span> <span class="n">form_tag</span> <span class="n">uploads_path</span><span class="p">,</span> <span class="ss">class: </span><span class="s2">"dropzone"</span><span class="p">,</span> <span class="ss">id: </span><span class="s2">"uploader"</span> <span class="k">do</span> <span class="cp">%&gt;</span>

<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">dropzone</code> class is the special bit here: Dropzone will automatically apply itself to any element with this class. If you’ve done this correctly, you’ll see this:</p>

<p><img src="/images/dropzone/drop-files-to-upload.png" alt="Test" /></p>

<p>The styling isn’t exactly pretty, but that’s something you can fix up later. (<a href="https://gist.github.com/radar/4e2957edf84efb40e222b43439e772a1">Here’s the CSS</a> that I use for my own; I think I cribbed it from the Dropzone site.)</p>

<p>What this will do is submit files to the <code class="language-plaintext highlighter-rouge">uploads_path</code>, as if there was a file input and we had selected a file and hit “submit”. If we had a controller action to receive these files, it might look something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">create</span>
  <span class="no">Photo</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">photo: </span><span class="n">params</span><span class="p">[</span><span class="ss">:file</span><span class="p">])</span>

  <span class="n">head</span> <span class="ss">:ok</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This action would use Paperclip to do the processing and resizing. The configuration in the <code class="language-plaintext highlighter-rouge">Photo</code> model would look like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">has_attached_file</span> <span class="ss">:photo</span><span class="p">,</span>
  <span class="ss">styles: </span><span class="p">{</span> <span class="ss">small: </span><span class="s2">"250x250#"</span><span class="p">,</span> <span class="ss">large: </span><span class="s2">"1000x1000#"</span><span class="p">}</span>
</code></pre></div></div>

<p>This would all result in the files being stored locally, in the <code class="language-plaintext highlighter-rouge">public/system</code> directory of the application. This might suit some, but for an application hosted on Heroku it is a terrible idea, because Heroku’s filesystem is read-only; your uploads would fail.</p>

<p>So let’s assume that this application is going to be hosted on Heroku. That means that we need to find somewhere else to host our files, and one very good place for that is Amazon S3.</p>

<h3 id="upload-direct-to-s3">Upload direct to S3</h3>

<p>There’s an interim step here where you could configure Paperclip to upload the files to S3 after it has finished processing them on the server. In fact, there’s a <a href="https://devcenter.heroku.com/articles/paperclip-s3">great Heroku tutorial</a> demonstrating just that.</p>

<p>However, as I mentioned at the beginning, we’re looking to upload files <em>directly</em> to s3 to avoid Heroku’s 30 second timeout. The Rails app may not have time to process the upload before the timeout if the file is sufficiently large enough. Therefore configuring Paperclip in this way won’t suit us. What we’ll do instead is upload this file directly to S3.</p>

<p><strong>I will assume at this stage that you’ve setup an AWS account and at least one S3 bucket to receive uploads into. I will also assume that you know what an AWS access key and AWS secret key are. If you haven’t configured these things, then go ahead and do that now.</strong></p>

<p><strong>I highly recommend creating a new user that only has read + write access to S3, and even then that access is limited to just this bucket. Your default user has <em>all</em> the permissions, and so if your keys leaked then someone could access your entire AWS account. Be careful.</strong></p>

<p>To let users upload to our application, we’ll need to use an S3 feature called a <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/PresignedUrlUploadObject.html"><em>presigned post</em></a>. S3 Buckets by default are not writeable by the general public. In this particular case, we <em>do</em> want the general public to upload files to our bucket.</p>

<p>This feature will allow us to generate a URL and some fields for our upload form. The combination of this URL and these fields will allow regular users of our application to upload files straight to our S3 bucket.</p>

<p>To use any AWS feature in our application, we first need to add the <code class="language-plaintext highlighter-rouge">aws-sdk</code> gem to our Gemfile:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gem</span> <span class="s1">'aws-sdk'</span><span class="p">,</span> <span class="s1">'~&gt; 2'</span>
</code></pre></div></div>

<p>We can use this gem to generate a presigned post, but before that we need to setup some credentials within our application. I like to use the <a href="https://rubygems.org/gems/dotenv-rails">dotenv-rails</a> gem for this purpose:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gem</span> <span class="s1">'dotenv-rails'</span>
</code></pre></div></div>

<p>This gem will load any environment variable specified in an <code class="language-plaintext highlighter-rouge">.env</code> file. Let’s create one of those now with these values:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AWS_ACCESS_KEY_ID=[your access key goes here]
AWS_SECRET_KEY=[your secret key goes here]
AWS_REGION=[your region name goes here]
AWS_BUCKET=[your bucket name goes here]
</code></pre></div></div>

<p><strong>NOTE: Make sure to add this <code class="language-plaintext highlighter-rouge">.env</code> file to <code class="language-plaintext highlighter-rouge">.gitignore</code>. You don’t want to commit your AWS access keys!</strong></p>

<p>Now let’s go ahead and generate a presigned post in the Rails console:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">resource</span> <span class="o">=</span> <span class="no">Aws</span><span class="o">::</span><span class="no">S3</span><span class="o">::</span><span class="no">Resource</span><span class="p">.</span><span class="nf">new</span>
<span class="n">post</span> <span class="o">=</span> <span class="n">resource</span><span class="p">.</span><span class="nf">bucket</span><span class="p">(</span><span class="no">ENV</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s2">"AWS_BUCKET"</span><span class="p">)).</span><span class="nf">presigned_post</span><span class="p">(</span>
  <span class="ss">key: </span><span class="s2">"uploads/</span><span class="si">#{</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_i</span><span class="si">}</span><span class="s2">/${filename}"</span>
<span class="p">)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">aws-sdk</code> gem will automatically reference the <code class="language-plaintext highlighter-rouge">AWS_ACCESS_KEY_ID</code>, <code class="language-plaintext highlighter-rouge">AWS_SECRET_KEY</code> and <code class="language-plaintext highlighter-rouge">AWS_REGION</code> keys from the environment to correctly configure itself. If you don’t believe me, try these three methods:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">resource</span><span class="p">.</span><span class="nf">client</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">credentials</span><span class="p">.</span><span class="nf">access_key_id</span>
<span class="n">resource</span><span class="p">.</span><span class="nf">client</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">credentials</span><span class="p">.</span><span class="nf">secret_access_key</span>
<span class="n">resource</span><span class="p">.</span><span class="nf">client</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">region</span>
</code></pre></div></div>

<p>They will return the same values as specified in <code class="language-plaintext highlighter-rouge">.env</code>, if you’ve configured all the above correctly.</p>

<p>Let’s go back and look at what that <code class="language-plaintext highlighter-rouge">post</code> is. It’s an instance of <code class="language-plaintext highlighter-rouge">Aws::S3::PresignedPost</code>, and it has two main methods that you need to know about: <code class="language-plaintext highlighter-rouge">url</code> and <code class="language-plaintext highlighter-rouge">fields</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">url</code> method is easy: it returns the URL to the bucket that will contain your uploaded files. Something like <code class="language-plaintext highlighter-rouge">https://[bucket].s3-[region].amazonaws.com</code>. Yours might be slightly different depending on the region you specified.</p>

<p>The <code class="language-plaintext highlighter-rouge">fields</code> method is a little more complicated. It will return a hash with the following keys:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">key</code>: The path where the file will live. We specified a timestamp and <code class="language-plaintext highlighter-rouge">${filename}</code> here. The <code class="language-plaintext highlighter-rouge">${filename}</code> part will be replaced by the name of the actual file when it has been uploaded.</li>
  <li><code class="language-plaintext highlighter-rouge">policy</code>: A Base64 encoded JSON blob, listing the policy for this post. For more info, <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/example-bucket-policies.html">read here</a>.</li>
  <li><code class="language-plaintext highlighter-rouge">x-amz-credential</code>: Specifies the access key used, the current date, and the scope to where this particular credential is used.</li>
  <li><code class="language-plaintext highlighter-rouge">x-amz-algorithm</code>: The encryption algorithm used to generate the signature.</li>
  <li><code class="language-plaintext highlighter-rouge">x-amz-date</code>: Today’s date.</li>
  <li><code class="language-plaintext highlighter-rouge">x-amz-signature</code>: The “signed” part of the request. A unique signature which verifies this request. For information on how this is constructed, <a href="http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html#query-string-auth-v4-signing">read this</a>.</li>
</ul>

<p>When we’re building our form, we need to use both the <code class="language-plaintext highlighter-rouge">url</code> and the <code class="language-plaintext highlighter-rouge">fields</code> parts of this <code class="language-plaintext highlighter-rouge">PresignedPost</code>. The combination of these two things will authenticate users with AWS and allow them to put files in our S3 buckets. We must generate the <code class="language-plaintext highlighter-rouge">PresignedPost</code> object server-side first, which we can do in our <code class="language-plaintext highlighter-rouge">UploadsController</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UploadsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">new</span>
    <span class="n">s3</span> <span class="o">=</span> <span class="no">Aws</span><span class="o">::</span><span class="no">S3</span><span class="o">::</span><span class="no">Resource</span><span class="p">.</span><span class="nf">new</span>
    <span class="vi">@post</span> <span class="o">=</span> <span class="n">s3</span><span class="p">.</span><span class="nf">bucket</span><span class="p">(</span><span class="no">ENV</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s1">'AWS_BUCKET'</span><span class="p">)).</span><span class="nf">presigned_post</span><span class="p">(</span>
      <span class="ss">key: </span><span class="s2">"uploads/</span><span class="si">#{</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_i</span><span class="si">}</span><span class="s2">/${filename}"</span><span class="p">,</span>
      <span class="ss">allow_any: </span><span class="p">[</span><span class="s1">'utf8'</span><span class="p">,</span> <span class="s1">'authenticity_token'</span><span class="p">],</span>
      <span class="ss">acl: </span><span class="s2">"authenticated-read"</span><span class="p">,</span>
    <span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We’re generating that <code class="language-plaintext highlighter-rouge">PresignedPost</code> here the same way as we’ve done in the console, with two small differences: we’re using an <code class="language-plaintext highlighter-rouge">allow_any</code> and an <code class="language-plaintext highlighter-rouge">acl</code> key.</p>

<p>Rails forms automatically insert two fields called <code class="language-plaintext highlighter-rouge">utf8</code> and <code class="language-plaintext highlighter-rouge">authenticity_token</code>. AWS uses the fields of the request to build the signature, and if any extra fields are added to the request then that may alter the signature. By using <code class="language-plaintext highlighter-rouge">allow_any</code> here, we’re saying that it’s OK for these fields to be <em>present</em>, and we don’t – and AWS shouldn’t – necessarily care about what those fields’ values are.</p>

<p>If we didn’t specify this <code class="language-plaintext highlighter-rouge">allow_any</code> key, our upload would fail with a “403 Forbidden” status, and the response body would say:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Error&gt;</span>
  <span class="nt">&lt;Code&gt;</span>AccessDenied<span class="nt">&lt;/Code&gt;</span>
    <span class="nt">&lt;Message&gt;</span>Invalid according to Policy: Extra input fields: utf8<span class="nt">&lt;/Message&gt;</span>
    ...
<span class="nt">&lt;/Error&gt;</span>
</code></pre></div></div>

<p>By setting up this little bit of configuration now, we avoid those issues later on.</p>

<p>The <code class="language-plaintext highlighter-rouge">acl</code> key will configure our uploaded objects permissions in such a way that only signed S3 requests can read those files.</p>

<p>Now with the <code class="language-plaintext highlighter-rouge">PresignedPost</code> generated server-side, we’re going to need to change our upload form to use that <code class="language-plaintext highlighter-rouge">PresignedPost</code>’s <code class="language-plaintext highlighter-rouge">url</code> and <code class="language-plaintext highlighter-rouge">fields</code>. Let’s change <code class="language-plaintext highlighter-rouge">app/views/uploads/new.html.erb</code> to this:</p>

<div class="language-erb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;%=</span> <span class="n">form_tag</span> <span class="vi">@post</span><span class="p">.</span><span class="nf">url</span><span class="p">,</span> <span class="ss">class: </span><span class="s2">"dropzone"</span><span class="p">,</span> <span class="ss">id: </span><span class="s2">"uploader"</span> <span class="k">do</span> <span class="cp">%&gt;</span>
  <span class="cp">&lt;%</span> <span class="vi">@post</span><span class="p">.</span><span class="nf">fields</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span> <span class="cp">%&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">hidden_field_tag</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="cp">%&gt;</span>
  <span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre></div></div>

<p>These simple changes will now use the <code class="language-plaintext highlighter-rouge">PresignedPost</code> object’s <code class="language-plaintext highlighter-rouge">url</code> and <code class="language-plaintext highlighter-rouge">fields</code> to build out our form. When files are uploaded, they will go to the S3 bucket that we specified with <code class="language-plaintext highlighter-rouge">AWS_BUCKET</code> in <code class="language-plaintext highlighter-rouge">.env</code>.</p>

<p>There’s one more small configuration change that we need to make on the AWS side of things before this will all work, and that’s CORS (Cross-Origin Resource Sharing). Open up your S3 bucket in the AWS console, go to Permissions, and then CORS Configuration and paste in this:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;CORSConfiguration&gt;</span>
 <span class="nt">&lt;CORSRule&gt;</span>
   <span class="nt">&lt;AllowedOrigin&gt;</span>*<span class="nt">&lt;/AllowedOrigin&gt;</span>

   <span class="nt">&lt;AllowedMethod&gt;</span>PUT<span class="nt">&lt;/AllowedMethod&gt;</span>
   <span class="nt">&lt;AllowedMethod&gt;</span>POST<span class="nt">&lt;/AllowedMethod&gt;</span>
   <span class="nt">&lt;AllowedMethod&gt;</span>GET<span class="nt">&lt;/AllowedMethod&gt;</span>

   <span class="nt">&lt;AllowedHeader&gt;</span>*<span class="nt">&lt;/AllowedHeader&gt;</span>
 <span class="nt">&lt;/CORSRule&gt;</span>
<span class="nt">&lt;/CORSConfiguration&gt;</span>
</code></pre></div></div>

<p>You may want to set the <code class="language-plaintext highlighter-rouge">AllowedOrigin</code> to your website here; I’ve just left it as an asterisk to make it easier for myself. This configuration allows any authenticated website’s users to issue <code class="language-plaintext highlighter-rouge">PUT</code>, <code class="language-plaintext highlighter-rouge">POST</code> and <code class="language-plaintext highlighter-rouge">GET</code> requests to this S3 bucket. If we tried to do an upload without this configuration, we would see an error that said:</p>

<blockquote>
  <p>XMLHttpRequest cannot load https://[bucket].s3-[region].amazonaws.com/. Response to preflight request doesn’t pass access control check: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://localhost:3000’ is therefore not allowed access. The response had HTTP status code 403.</p>
</blockquote>

<p>With this configuration in place, it should now be possible to upload a file to the bucket:</p>

<p><img src="/images/dropzone/successful-upload.gif" alt="Successful upload" /></p>

<p>This is what you should see too with your upload.</p>

<h3 id="recording-the-upload">Recording the upload</h3>

<p>Our upload now arrives safely on S3, but we currently do not have any record of it within our application. With Paperclip, when a file is uploaded we have to attach it to a particular model’s instance, and through that model instance we track the location of the file. When we upload directly to S3, we don’t have that same kind of “automatic” tracking that Paperclip provides.</p>

<p>We’re going to have to come up with another way of recording this upload within our application. Some hipster ops would probably recommend that you trigger an AWS lambda event whenever a file is uploaded to the bucket, and then that event posts back to your application… but I think that is a touch too complicated.</p>

<p>What we’ll do instead is to get S3 to report back after the file has been successfully uploaded. S3 will do this in the response it returns from a file upload request, as long as we configure it to do so. This response will contain the location of the file that has been uploaded, and then with that information we can then create an <code class="language-plaintext highlighter-rouge">Upload</code> record.</p>

<p>To make S3 report back information about the upload, we need to make a small change to our controller. We’ll need to add an extra key to our <code class="language-plaintext highlighter-rouge">presigned_post</code> call:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@post</span> <span class="o">=</span> <span class="n">s3</span><span class="p">.</span><span class="nf">bucket</span><span class="p">(</span><span class="no">ENV</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s1">'AWS_BUCKET'</span><span class="p">)).</span><span class="nf">presigned_post</span><span class="p">(</span>
  <span class="ss">key: </span><span class="s2">"uploads/</span><span class="si">#{</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_i</span><span class="si">}</span><span class="s2">/${filename}"</span><span class="p">,</span>
  <span class="ss">allow_any: </span><span class="p">[</span><span class="s1">'utf8'</span><span class="p">,</span> <span class="s1">'authenticity_token'</span><span class="p">],</span>
  <span class="ss">success_action_status: </span><span class="mi">201</span><span class="p">,</span>
<span class="p">)</span>
</code></pre></div></div>

<p>This small change tells S3 that we would like a response back. By default, S3 returns a “204 No Content” status. This configuration option changes that to a “201 Created”, which will contain a response body that contains the file information.</p>

<p>The next issue that we have to deal with is that Dropzone + S3 are handling the upload, and we don’t currently have a way to intercept the response back from S3. Fortunately, Dropzone is easily configurable and so we can get it perform an action once a file has been uploaded successfully.</p>

<p>Let’s configure Dropzone like this now:</p>

<p><strong>app/assets/javascripts/uploads.js</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Dropzone</span><span class="p">.</span><span class="nx">autoDiscover</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

<span class="nx">$</span><span class="p">(</span><span class="nb">document</span><span class="p">).</span><span class="nx">ready</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">myDropzone</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Dropzone</span><span class="p">(</span><span class="dl">'</span><span class="s1">#uploader</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">timeout</span><span class="p">:</span> <span class="mi">0</span> <span class="p">});</span>

  <span class="nx">myDropzone</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">success</span><span class="dl">"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="nx">request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">request</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">resp</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">parseXML</span><span class="p">(</span><span class="nx">request</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">filePath</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="nx">resp</span><span class="p">).</span><span class="nx">find</span><span class="p">(</span><span class="dl">"</span><span class="s2">Key</span><span class="dl">"</span><span class="p">).</span><span class="nx">text</span><span class="p">();</span>

    <span class="nx">$</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="dl">'</span><span class="s1">/uploads</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">authenticity_token</span><span class="p">:</span> <span class="nx">$</span><span class="p">.</span><span class="nx">rails</span><span class="p">.</span><span class="nx">csrfToken</span><span class="p">(),</span>
      <span class="na">upload</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">path</span><span class="p">:</span> <span class="nx">filePath</span><span class="p">,</span>
        <span class="na">file_type</span><span class="p">:</span> <span class="nx">file</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span>
        <span class="na">last_modified</span><span class="p">:</span> <span class="nx">file</span><span class="p">.</span><span class="nx">lastModified</span>
      <span class="p">}</span>
    <span class="p">})</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Again, I’m going a bit “old-school” with the jQuery usage. Sorry, JS hipsters. This could very well <a href="https://github.com/founderlab/react-dropzone-s3-uploader">just as easily be a React component</a>, but I’m wanting to keep it relatively simple here.</p>

<p>The first thing that we do here is to turn off Dropzone’s autodiscovery. We do this because we want to configure a custom dropzone component, but at the same time we want to keep the styling provided by <code class="language-plaintext highlighter-rouge">dropzone.css</code>. This styling refers to the class <code class="language-plaintext highlighter-rouge">dropzone</code>, but Dropzone’s autodiscovery feature applies dropzone to any element with that class. So to have the styling but <em>not</em> the autodiscovery, we disable this option.</p>

<p>Then we go about configuring the custom Dropzone component. We start by linking it to the <code class="language-plaintext highlighter-rouge">#uploader</code> element (our <code class="language-plaintext highlighter-rouge">form_tag</code>), and setting the timeout to 0. By default Dropzone’s timeout is 30 seconds, just like Heroku’s. If we have a large file that we’re uploading through Dropzone and/or a slow (read: Australian) internet connection, then Dropzone will cancel the request after 30 seconds. This option disables that feature.</p>

<p>The <code class="language-plaintext highlighter-rouge">on</code> function call then sets a handler for a “success” event, which is what happens right after a file has been uploaded. The first argument to this callback is the <code class="language-plaintext highlighter-rouge">file</code> which has just been uploaded, and contains some handy information like the file’s content type and its last modification date.</p>

<p>The content type can come in handy if you want to display different files differently. For instance, for images you might want to display a smallnail but for a video or a PDF file you might want to display an icon.</p>

<p>The <code class="language-plaintext highlighter-rouge">request</code> argument represents the response that we get back from S3 after the file has been uploaded. Because of that <code class="language-plaintext highlighter-rouge">success_action_status</code> configuration in our controller, this response will be a short XML document.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;PostResponse&gt;</span>
  <span class="nt">&lt;Location&gt;</span>https://[bucket].s3-[region].amazonaws.com/[file]<span class="nt">&lt;/Location&gt;</span>
  <span class="nt">&lt;Bucket&gt;</span>[bucket]<span class="nt">&lt;/Bucket&gt;</span>
  <span class="nt">&lt;Key&gt;</span>[file]<span class="nt">&lt;/Key&gt;</span>
  <span class="nt">&lt;ETag&gt;</span>[etag]<span class="nt">&lt;/ETag&gt;</span>
<span class="nt">&lt;/PostResponse&gt;</span>
</code></pre></div></div>

<p>From this XML response, we extract the <code class="language-plaintext highlighter-rouge">Key</code> element by using jQuery’s <code class="language-plaintext highlighter-rouge">$.parseXML</code> function, and then send that through in a <code class="language-plaintext highlighter-rouge">POST</code> request with <code class="language-plaintext highlighter-rouge">$.post</code> to <code class="language-plaintext highlighter-rouge">/uploads</code>. With this request, we need to send through the authenticity token, which we get with <code class="language-plaintext highlighter-rouge">$.rails.csrfToken</code>.</p>

<p>This request will hit the <code class="language-plaintext highlighter-rouge">create</code> action of our <code class="language-plaintext highlighter-rouge">UploadsController</code> which doesn’t yet exist, so let’s create it:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">create</span>
  <span class="no">Upload</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="n">upload_params</span><span class="p">)</span>

  <span class="n">head</span> <span class="ss">:ok</span>
<span class="k">end</span>

<span class="kp">private</span>

<span class="k">def</span> <span class="nf">upload_params</span>
  <span class="n">params</span><span class="p">.</span><span class="nf">require</span><span class="p">(</span><span class="ss">:upload</span><span class="p">).</span><span class="nf">permit</span><span class="p">(</span><span class="ss">:path</span><span class="p">,</span> <span class="ss">:file_type</span><span class="p">,</span> <span class="ss">:last_modified</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>With all this hooked up, we should now see uploads coming through to this controller. Go ahead and upload one and give it a spin. If it’s successful, you’ll see something like this in the Rails server output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Started POST "/uploads" for 127.0.0.1 at 2017-08-29 10:36:38 +1000
Processing by UploadsController#create as */*
  Parameters: {
    "authenticity_token"=&gt;"[token]",
    "upload"=&gt;{
      "path"=&gt;"uploads/1503966995/joe.png",
      "file_type"=&gt;"image/png",
      "last_modified"=&gt;"1503965717000"
    }}
   (0.1ms)  begin transaction
  SQL (0.5ms)  INSERT INTO "uploads" ...
   (1.5ms)  commit transaction
Completed 200 OK in 21ms (ActiveRecord: 2.8ms)
</code></pre></div></div>

<p>Hooray!</p>

<p>One issue though: if we display these uploads from S3 then they’ll be displayed in their original resolutions. With Paperclip, it automatically resized uploads to smallnail or smaller versions, but with direct-to-S3 upload we’re missing out on that feature. Let’s look at how we can add that feature back to our app with imgix.</p>

<h3 id="serving-images-using-imgix">Serving images using imgix</h3>

<p><a href="https://imgix.com">imgix</a> is a real-time image processing and CDN service. We can use them to dynamically resize the photos uploaded to our application.</p>

<p>imgix takes image hosting quite seriously. <a href="http://photos.imgix.com/building-a-graphics-card-for-the-internet">Take a look at their “Building a Graphics Card for the Internet” writeup + photos</a> just to see how serious they are about it.</p>

<p>Signing up is free, and they give you a $10 credit on signing up. That should be plenty to at least trial this.</p>

<p>Sign up to imgix, and create a new source. For the “Source Type” you’ll want to choose “Amazon S3”, and then you’ll need to fill in the AWS Settings. The images do not have a path prefix, so leave that blank. Under “Security” check “Secure URLs”. For why you’d want to check that box, read <a href="https://docs.imgix.com/setup/securing-images">this page from imgix’s docs</a>.</p>

<p>Once you’ve setup the source, you’ll need to get the token from under the “Security” section. It will look like <code class="language-plaintext highlighter-rouge">5pXdqzZw69drsRgB</code>. We’ll use this token to securely sign our imgix URLs.</p>

<p>To generate these URLs, we can use the <code class="language-plaintext highlighter-rouge">imgix</code> gem. Let’s add that to the <code class="language-plaintext highlighter-rouge">Gemfile</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gem</span> <span class="s1">'imgix'</span><span class="p">,</span> <span class="s1">'~&gt; 1.1.0'</span>
</code></pre></div></div>

<p>Then run <code class="language-plaintext highlighter-rouge">bundle install</code>. Let’s add our secure token to the <code class="language-plaintext highlighter-rouge">.env</code> file, just so it’s not in our committed code. We’ll also add in the subdomain for the source that we setup:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IMGIX_TOKEN=5pXdqzZw69drsRgB
IMGIX_SUBDOMAIN=[your subdomain goes here]
</code></pre></div></div>

<p>We’re adding in the subdomain here as it will be different for our production environment. The subdomain here should be a <em>development-specific</em> one.</p>

<p>With that there, let’s now try generating an imgix URL with this gem in the rails console. First, we’ll need an <code class="language-plaintext highlighter-rouge">Imgix::Client</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">client</span> <span class="o">=</span> <span class="no">Imgix</span><span class="o">::</span><span class="no">Client</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">host: </span><span class="s2">"</span><span class="si">#{</span><span class="no">ENV</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s2">"IMGIX_SUBDOMAIN"</span><span class="p">)</span><span class="si">}</span><span class="s2">.imgix.net"</span><span class="p">,</span>
  <span class="ss">secure_url_token: </span><span class="no">ENV</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s2">"IMGIX_TOKEN"</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div></div>

<p>Then to sign a URL, we can use <code class="language-plaintext highlighter-rouge">Imgix::Client#path</code>. By this point, we should have at least one upload, so let’s use that upload’s path to generate this URL:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">path</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">path</span><span class="p">(</span><span class="no">Upload</span><span class="p">.</span><span class="nf">last</span><span class="p">.</span><span class="nf">path</span><span class="p">)</span>
</code></pre></div></div>

<p>This gives us an <code class="language-plaintext highlighter-rouge">Imgix::Path</code> object. We can transform this path into a URL with the <code class="language-plaintext highlighter-rouge">to_url</code> method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">path</span><span class="p">.</span><span class="nf">to_url</span>
</code></pre></div></div>

<p>The URL returned here will look something like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://[imgix subdomain].imgix.net/uploads/[path]?ixlib=rb-1.1.0&amp;s=[signature]
</code></pre></div></div>

<p>If you open this URL in your browser you’ll see the image that you have just uploaded, at the resolution you uploaded it. This is a good thing, as it proves that imgix’s proxying service is working: imgix is fetching the image from the S3 bucket and serving the image through the imgix CDN.</p>

<p>The next step that we want to acheive is to get imgix to dynamically resize these photos. Let’s say that we want an image that’s 250×250 pixels to use as our smallnail. To get imgix to generate an image like that, we need to pass some options to <code class="language-plaintext highlighter-rouge">to_url</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>path.to_url(w: 250, h: 250)
</code></pre></div></div>

<p>This will return an image that maintains its aspect ratio, but at least the width or the height is a maximum of 250 pixels. Let me explain what I mean by this with an example: I have an image hosted through imgix that is 3264×2448 pixels. With the above options, imgix resizes this image to 250×188, effectively reducing the measurements of the photo by a ratio of 13.058.</p>

<p>However, in this particular application I want images that are perfect squares because I display these photos in a grid fashion. You might want this too, and so to generate images like this we can use the <code class="language-plaintext highlighter-rouge">:fit</code> option in <code class="language-plaintext highlighter-rouge">to_url</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>path.to_url(w: 250, h: 250, fit: 'crop')
</code></pre></div></div>

<p>imgix will now crop the image so that it fits neatly into a 250×250 square. There are <a href="https://docs.imgix.com/apis/url/size/fit">other styles of cropping, which are explained here</a>. You can load up the two images in two browser tabs to compare what they look like.</p>

<p>Let’s make our images do this now through our view, and not just through the console. We can create a new class for this at <code class="language-plaintext highlighter-rouge">lib/upload_url.rb</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UploadURL</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@client</span> <span class="o">=</span> <span class="no">Imgix</span><span class="o">::</span><span class="no">Client</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
      <span class="ss">host: </span><span class="s2">"</span><span class="si">#{</span><span class="no">ENV</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s2">"IMGIX_SUBDOMAIN"</span><span class="p">)</span><span class="si">}</span><span class="s2">.imgix.net"</span><span class="p">,</span>
      <span class="ss">secure_url_token: </span><span class="no">ENV</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s2">"IMGIX_TOKEN"</span><span class="p">)</span>
    <span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">small_url</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="vi">@client</span><span class="p">.</span><span class="nf">path</span><span class="p">(</span><span class="n">path</span><span class="p">).</span><span class="nf">to_url</span><span class="p">(</span><span class="ss">w: </span><span class="mi">250</span><span class="p">,</span> <span class="ss">h: </span><span class="mi">250</span><span class="p">,</span> <span class="ss">fit: </span><span class="s1">'crop'</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">large_url</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="vi">@client</span><span class="p">.</span><span class="nf">path</span><span class="p">(</span><span class="n">path</span><span class="p">).</span><span class="nf">to_url</span><span class="p">(</span><span class="ss">w: </span><span class="mi">1000</span><span class="p">,</span> <span class="ss">h: </span><span class="mi">1000</span><span class="p">,</span> <span class="ss">fit: </span><span class="s1">'crop'</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Then we can use this new class in <code class="language-plaintext highlighter-rouge">UploadsHelper</code>:</p>

<p><em>app/helpers/uploads_helper.rb</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require_dependency 'upload_url'

module UploadsHelper
  def small_image(upload)
    image_tag(upload_url.small_url(upload.path))
  end

  def large_image(upload)
    image_tag(upload_url.large_url(upload.path))
  end

  private

  def upload_url
    @upload_url ||= UploadURL.new
  end
end
</code></pre></div></div>

<p>We can then use these helpers to display smallnail versions of our image on the <code class="language-plaintext highlighter-rouge">index</code> template:</p>

<p><strong>app/views/uploads/index.html.erb</strong></p>

<div class="language-erb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;h1&gt;</span>Uploads<span class="nt">&lt;/h1&gt;</span>

<span class="cp">&lt;%</span> <span class="vi">@uploads</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">upload</span><span class="o">|</span> <span class="cp">%&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">small_image</span><span class="p">(</span><span class="n">upload</span><span class="p">)</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre></div></div>

<p>Or large images on the <code class="language-plaintext highlighter-rouge">show</code> template:</p>

<p><strong>app/views/uploads/show.html.erb</strong></p>

<div class="language-erb highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
  <span class="cp">&lt;%=</span> <span class="n">large_image</span><span class="p">(</span><span class="vi">@upload</span><span class="p">)</span> <span class="cp">%&gt;</span>
...
</code></pre></div></div>

<h3 id="summary">Summary</h3>

<p>Dropzone, S3 and imgix allow us to upload and host our images very easily, without the need of the paperclip gem. By uploading directly to S3, we avoid tying up our application’s processes with lengthy file uploads too.</p>

<p>If you found this post helpful, chuck a few bucks my way on PayPal: <a href="https://paypal.me/ryanbigg">https://paypal.me/ryanbigg</a>.</p>


          </article>
        </div>
      </div>
    </div>
    <footer>
    01101110 01101111 01110100 01101000 01101001 01101110 01100111 00100000 01110100 01101111 00100000 01110011 01100101 01100101 00100000 01101000 01100101 01110010 01100101 0001010 0001010 0001010 0001010 0001010 01100010 01110010 01100001 01110110 01101111 00100000 01100110 01101111 01111000 01110100 01110010 01101111 01110100 00100000 01110101 01101110 01101001 01100110 01101111 01110010 01101101
</footer>


    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-60556315-1', 'auto');
      ga('send', 'pageview');

    </script>
  </body>
</html>
